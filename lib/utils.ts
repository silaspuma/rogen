/**
 * Utility functions for the Roblox Game Generator
 */

// Generate a unique game ID
export const generateGameId = (): string => {
  return `game_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
};

// Format date to readable string
export const formatDate = (date: Date): string => {
  return new Intl.DateTimeFormat('en-US', {
    year: 'numeric',
    month: 'short',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
  }).format(date);
};

// Truncate text with ellipsis
export const truncate = (text: string, length: number): string => {
  if (text.length <= length) return text;
  return text.substr(0, length) + '...';
};

// Validate email
export const isValidEmail = (email: string): boolean => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
};

// Get game type color
export const getGameTypeColor = (type: string): string => {
  const colors: Record<string, string> = {
    puzzle: 'bg-blue-500',
    adventure: 'bg-green-500',
    racing: 'bg-red-500',
    survival: 'bg-yellow-500',
    shooter: 'bg-purple-500',
    other: 'bg-gray-500',
  };
  return colors[type.toLowerCase()] || colors.other;
};

// Get game type emoji
export const getGameTypeEmoji = (type: string): string => {
  const emojis: Record<string, string> = {
    puzzle: 'ğŸ§©',
    adventure: 'ğŸ—ºï¸',
    racing: 'ğŸï¸',
    survival: 'ğŸ•ï¸',
    shooter: 'ğŸ¯',
    platformer: 'ğŸ®',
    rpg: 'âš”ï¸',
    tycoon: 'ğŸ’°',
  };
  return emojis[type.toLowerCase()] || 'ğŸ®';
};

// Delay function for async operations
export const delay = (ms: number): Promise<void> => {
  return new Promise(resolve => setTimeout(resolve, ms));
};

// Generate mock Lua script based on game type
export const generateMockLuaScript = (gameType: string, gameName: string): string => {
  return `--[[
  Generated Roblox Game: ${gameName}
  Type: ${gameType}
  Generated by RoboxGen AI
  
  This is a starting template for your ${gameType} game.
  Customize as needed for your specific game mechanics.
]]

local game = game
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- Game Configuration
local GAME_NAME = "${gameName}"
local GAME_TYPE = "${gameType}"
local VERSION = "1.0.0"

-- Initialize game
print("Initializing " .. GAME_NAME)

-- Player connection handler
Players.PlayerAdded:Connect(function(player)
    print(player.Name .. " joined the game!")
    
    -- Create player-specific instances
    local character = player.Character or player.CharacterAdded:Wait()
    
    -- Add starter gear
    if GAME_TYPE == "adventure" then
        -- Adventure starter items
        print("Loading adventure starter items...")
    elseif GAME_TYPE == "puzzle" then
        -- Puzzle solver items
        print("Loading puzzle items...")
    elseif GAME_TYPE == "racing" then
        -- Racing car setup
        print("Loading racing setup...")
    end
end)

-- Main game loop
RunService.Heartbeat:Connect(function(deltaTime)
    -- Update game logic here
    -- This runs every frame
end)

print(GAME_NAME .. " loaded successfully!")
`;
};

// Format file size
export const formatFileSize = (bytes: number): string => {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return Math.round((bytes / Math.pow(k, i)) * 100) / 100 + ' ' + sizes[i];
};

// Copy text to clipboard
export const copyToClipboard = async (text: string): Promise<boolean> => {
  try {
    await navigator.clipboard.writeText(text);
    return true;
  } catch (err) {
    console.error('Failed to copy:', err);
    return false;
  }
};
